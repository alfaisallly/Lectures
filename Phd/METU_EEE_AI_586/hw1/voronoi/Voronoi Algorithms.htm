<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0078)http://www.cip.informatik.uni-muenchen.de/~viermetz/cg/Voronoi_Algorithms.html -->
<HTML><HEAD><TITLE>Voronoi Algorithms</TITLE>
<META http-equiv=content-type content="text/html; charset=ISO-8859-1">
<META content="MSHTML 6.00.2900.2802" name=GENERATOR></HEAD>
<BODY>Here is a list of all voronoi algorithms implemented in this applet, along 
with a short description and explanation.<BR>
<UL>
  <LI><A name=PlaneIntersect></A>
  <H4>Plane Intersect</H4>This algorithm is the straightforward naive approach 
  to generating a Voronoi diagram. 
  <H5>Motivation </H5>The impulse is given by the mathematical description for 
  genrating a Voronoi Cell, namely by merging all halfplanes generated by the 
  bisecting line between the site and all other sites in the plane. <BR><BR>
  <DIV align=center>
  <TABLE cellSpacing=5 cellPadding=5 width="80%" border=1>
    <THEAD></THEAD>
    <TBODY>
    <TR>
      <TD>
        <DIV align=center><CODE>V(p<SUB>i</SUB>) = merge <SUB>i!=j</SUB> 
        H(p<SUB>i</SUB>, p<SUB>j</SUB>)</CODE><BR>where <CODE>H(p<SUB>i</SUB>, 
        p<SUB>j</SUB>)</CODE> is the halfplane between site i and site j. 
      </DIV></TD></TR></TBODY></TABLE></DIV><BR>
  <H5>Illustration</H5>The basic principle is the following: Take each site in 
  the plain, and determine the bisection line between the point and every other 
  point and unify all halfplanes thus created. This process must be repeated for 
  each and every site in the plane. 
  <TABLE cellSpacing=5 width="90%">
    <TBODY>
    <TR>
      <TD><IMG alt="Step 1" src="Voronoi Algorithms_files/intersect-1.jpg" 
        border=1> </TD>
      <TD><IMG alt="Step 2" src="Voronoi Algorithms_files/intersect-2.jpg" 
        border=1> </TD></TR>
    <TR>
      <TD>Figure1 - <VAR>The first halfplane is found.</VAR></TD>
      <TD>Figure2 - <VAR>A second halfplane is found and merged with the first 
        one.</VAR></TD></TR>
    <TR>
      <TD><IMG alt="Step 3" src="Voronoi Algorithms_files/intersect-3.jpg" 
        border=1> </TD>
      <TD><IMG alt="Step 4" src="Voronoi Algorithms_files/intersect-4.jpg" 
        border=1> </TD></TR>
    <TR>
      <TD>Figure3 - <VAR>A third halfplane is merged with the other 
      two.</VAR></TD>
      <TD>Figure4 - <VAR>The resulting edge of the merged planes defines the 
        Voronoi Cell.</VAR></TD></TR></TBODY></TABLE>
  <H5>Complexity</H5>It is easy to see that the complexity in this case is 
  <CODE><B>O(n<SUP>2</SUP>)</B></CODE>. <BR><BR><BR>
  <LI><A name=PlaneSweep></A>
  <H4>Plane Sweep</H4>After the naive approach in the previous algorithm, this 
  one attempts to achieve some efficiency by cutting out some redundancy. 
  <H5>Motivation</H5>The basic idea for this algorithm is the additional 
  introduction of the concept of incremental generation. The diagram is 
  generated site by site, always inserting the last site into the diagram. 
  <BR>The methodology is as follows:<BR>After the sites have been sorted along 
  the increasing x-axis, in order to avoid inserting sites into the center, the 
  first diagram is generated. Afterwards the sites are subsequently inserted 
  into the fringe of the diagram, minimizing necessary cutting operations. 
  <H5>Illustration</H5>These steps show the start of a computation cycle, i.e. 
  the first three sites in the sorted list. 
  <TABLE cellSpacing=5 width="90%">
    <TBODY>
    <TR>
      <TD><IMG alt="Step 1" src="Voronoi Algorithms_files/sweep-1.jpg" 
        width="80%" border=1> </TD>
      <TD><IMG alt="Step 2" src="Voronoi Algorithms_files/sweep-2.jpg" 
        width="80%" border=1> </TD></TR>
    <TR>
      <TD>Figure 1 - <VAR>All sites are sorted by ascending x value.</VAR></TD>
      <TD>Figure 2 - <VAR>The first two are selected to generate the simplest 
        of all Voronoi diagrams.</VAR></TD></TR>
    <TR>
      <TD><IMG alt="Step 3" src="Voronoi Algorithms_files/sweep-3.jpg" 
        width="80%" border=1> </TD>
      <TD><IMG alt="Step 4" src="Voronoi Algorithms_files/sweep-4.jpg" 
        width="80%" border=1> </TD></TR>
    <TR>
      <TD>Figure 3 - <VAR>The third site is selected and added. The cell into 
        which it falls is determined.</VAR></TD>
      <TD>Figure 4 - <VAR>The bisector between the new site and it's host is 
        determined, the host cell is cut with this bisector.</VAR></TD></TR>
    <TR>
      <TD><IMG alt="Step 5" src="Voronoi Algorithms_files/sweep-5.jpg" 
        width="80%" border=1> </TD>
      <TD><IMG alt="Step 6" src="Voronoi Algorithms_files/sweep-6.jpg" 
        width="80%" border=1> </TD></TR>
    <TR>
      <TD>Figure 5 - <VAR>Through this cut in the last step, a neighbor cell 
        of the host cell has been affected, and a new bisector must also be 
        generated and inserted.</VAR></TD>
      <TD>Figure 6 - <VAR>In this case, this stage of the generation is 
        finished.</VAR></TD></TR></TBODY></TABLE>
  <H5>Complexity</H5>The Complexity for this algorithm is: <BR>Best case - 
  <CODE><B>O(n)</B></CODE><BR>Worst case - 
  <CODE><B>O(n<SUP>2</SUP>)</B></CODE><BR>Average - <CODE><B>O(n 
  log<SUB>n</SUB>)</B></CODE> <BR><BR><BR>
  <LI><A name=DivideAndConquer></A>
  <H4>Divide and Conquer</H4>Another approach to increasing efficiency is the 
  well known division and conquer method. As we have seen in the last algorithm, 
  it is quite possible and efficient to insert single sites into an already 
  calculated Voronoi Diagram. This approach might be generalized into the 
  process of inserting not one site, but several sites already merged into a 
  Voronoi Diagram. 
  <H5>Motivation</H5>The algorithm is naturally divided into two steps:<BR><BR>
  <UL type=->
    <LI>Divide :<BR>The sites in the plane are subsequently divided into two 
    halves along a successively determined bisecting line. 
    <LI>Conquer:<BR>The resulting binary tree with site in the leaves is 
    successively merged into ever increasing Voronoi diagrams. </LI></UL>
  <H5>Illustrtion</H5>Division: Two random sites are picked, and the sites 
  divided along the generated bisector line. Each subset is further divided 
  until only two or less elements are left, constituting the two simplest 
  possible of voronoi diagrams. 
  <TABLE cellSpacing=5 width="90%">
    <TBODY>
    <TR>
      <TD><IMG alt="Step 1" src="Voronoi Algorithms_files/divide-1.jpg" 
        border=1> </TD>
      <TD><IMG alt="Step 2" src="Voronoi Algorithms_files/divide-2.jpg" 
        border=1> </TD></TR>
    <TR>
      <TD>Figure 1 - <VAR>The sites in the plane</VAR></TD>
      <TD>Figure 2 - <VAR>The generated tree after division. Each node 
        represents a bisector.</VAR></TD></TR></TBODY></TABLE>Conquer: The leaves of 
  the tree are treated as finished Voronoi Diagrams. The interesting bit is the 
  merging of two sepereate Voronoi Diagrams representing the results of two 
  subtrees. 
  <TABLE cellSpacing=5 width="90%">
    <TBODY>
    <TR>
      <TD><IMG alt="Step 1" src="Voronoi Algorithms_files/conquer-1.jpg" 
        width="90%" border=1> </TD>
      <TD><IMG alt="Step 2" src="Voronoi Algorithms_files/conquer-2.jpg" 
        width="90%" border=1> </TD></TR>
    <TR>
      <TD>Figure 1 - <VAR>The two Voronoi sets to merge (blue and green). The 
        yellow line is the bisector between the sets.</VAR></TD>
      <TD>Figure 2 - <VAR>Each cell(red) along the common border between the 
        sets must now be clipped with its opposite member.</VAR></TD></TR>
    <TR>
      <TD><IMG alt="Step 3" src="Voronoi Algorithms_files/conquer-3.jpg" 
        width="90%" border=1> </TD>
      <TD><IMG alt="Step 4" src="Voronoi Algorithms_files/conquer-4.jpg" 
        width="90%" border=1> </TD></TR>
    <TR>
      <TD>Figure 3 - <VAR>The result for the first cell(red).</VAR></TD>
      <TD>Figure 4 - <VAR>The result for the second cell(red).</VAR></TD></TR>
    <TR>
      <TD><IMG alt="Step 5" src="Voronoi Algorithms_files/conquer-5.jpg" 
        width="90%" border=1> </TD></TR>
    <TR>
      <TD>Figure 5 - <VAR>Merged sets.</VAR></TD></TR></TBODY></TABLE>
  <H5>Complexity</H5>The complexity is determined by the two constituents of the 
  algorithm:<BR>Divide Step: <CODE><B>O(n log<SUB>n</SUB>)</B></CODE><BR>Conquer 
  Step: <CODE><B>O(n log<SUB>n</SUB>)</B></CODE><BR>Total complexity is then, 
  naturally, also <CODE><B>O(n log<SUB>n</SUB>)</B></CODE>.<BR><BR><BR>
  <LI><A name=Fortune></A>
  <H4>Fortune's Algorithm</H4>After the previous two algorithms, which were 
  constructed more according to general algorithm design principles, the 
  following algorithm was proposed by Fortune in 1985, improving upon the 
  efficacy, and guaranteeing a worst case performance of <CODE><B>O(n 
  log<SUB>n</SUB>)</B></CODE>. 
  <H5>Motivation</H5>The efficacy inherent in the algorithm is constituted in 
  the geometric assumptions from which the algorithm is derived. A cone with 45 
  degree angle is constructed centered on each site in the plane. A slanted 
  plane (45 degree angle) is now dragged across the coordinate system. The 
  intersection between the cones, when projected onto the x-y plane defines the 
  voronoi lines. when the angled plane moves across the x axis, the intersection 
  of the plane with the individual cones, when projected onto the x-y plane 
  clearly defines the intersection points of the individual parabola curves, and 
  thus the voronoi lines between the sites in the x-y plane. 
  <TABLE cellSpacing=5 width="90%">
    <TBODY>
    <TR>
      <TD><IMG alt=conediag src="Voronoi Algorithms_files/cone1.jpg" 
        width="80%" border=1></TD>
      <TD><IMG alt=conediag src="Voronoi Algorithms_files/cone2.jpg" 
        width="80%" border=1></TD></TR></TBODY></TABLE>
  <H5>Illustration</H5>
  <TABLE cellSpacing=5 width="90%">
    <TBODY>
    <TR>
      <TD><IMG alt="Step 1" src="Voronoi Algorithms_files/fortune-1.jpg" 
        width="90%" border=1> </TD>
      <TD><IMG alt="Step 2" src="Voronoi Algorithms_files/fortune-2.jpg" 
        width="90%" border=1> </TD></TR>
    <TR>
      <TD>Figure 1 - <VAR>First all sites must translate into a Point Event 
        (red circles) where the plane intersects a new cone, and a new parabola 
        is created.</VAR></TD>
      <TD>Figure 2 - <VAR>When the sweepline passes a Point Event, a new 
        parabola must be created and inserted into the wavefront.</VAR></TD></TR>
    <TR>
      <TD><IMG alt="Step 3" src="Voronoi Algorithms_files/fortune-3.jpg" 
        width="90%" border=1> </TD>
      <TD><IMG alt="Step 4" src="Voronoi Algorithms_files/fortune-4.jpg" 
        width="90%" border=1> </TD></TR>
    <TR>
      <TD>Figure 3 - <VAR>During the execution of a Point Event, the future 
        intersection between two voronoi lines can be determined (Circle Event - 
        green circle). </VAR></TD>
      <TD>Figure 4 - <VAR>At such coordinates a Circle Event (green circle) 
        must be executed to remove the disappearing parabola and terminate the 
        Voronoi Lines.</VAR></TD></TR></TBODY></TABLE>
  <H5>Complexity</H5>Worst Case: <CODE><B>O(n log<SUB>n</SUB>)</B></CODE>. Best 
  Case: <CODE><B>O(k * n)</B></CODE>. <BR><BR><BR>
  <LI><A name=Wavefront></A>
  <H4>Wave Front Visualization</H4>This is not an algorithm per se, but a 
  animation to simulate natural processes that generate designs as seen in 
  Voronoi Diagrams, such as crystal growth, or or maybe bacterium growth in a 
  petri dish.<BR>This algorithm also visually illustrates the intention of a 
  voronoin diagram, and the defining property of enclosing all points closer to 
  one site in the plane in a voronoi cell.<BR><IMG alt="Step 4" 
  src="Voronoi Algorithms_files/wave.jpg" border=1> 
<BR><BR><BR></LI></UL></BODY></HTML>
